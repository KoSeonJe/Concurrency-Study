# DB Lock

### 락(Lock)이란?

- 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 하나의 커넥션만 변경할 수 있게 해주는 기능
- 동시성을 제어하기 위한 기능

→ 외부에서 잠금을 거는 것이 아니라, 커넥션이 자원에게 접근한 뒤 해당 커넥션이 외부 커넥션에게 자원에 대한 접근을 잠금하는 것이라 생각하면 된다.

### 락의 종류

- 공유 Lock(Shared Lock, Read Lock, S-Lock)
- 배타 Lock(Exclusive Lock, Write Lock, X-Lock)

### 1-1 공유 락(Shared Lock, Read Lock, S-Lock)

- 공유 Lock은 **데이터를 변경하지 않는 읽기 작업을 위해 잠그는 것**을 말한다.
- 특정 데이터에 s-lock을 걸때
    - 하나의 세션 읽기 작업 - 다른 세션 읽기 작업
      → 데이터 정합성O, 다른 세션이 같은 데이터에게 s-lock을 얻는 것을 허용
    - 하나의 세션 읽기 작업 - 다른 세션 쓰기 작업
      → 데이터 정합성 X , 다른 세션의 x-Lock 얻는 것을 막음
    - 다른 세션에서 해당 데이터에 s-Lock을 걸고 접근 가능
    - 다른 세션에서 해당 데이터에 x-lock을 걸고 접근 불가능

—> A가 공유락을 얻는다면, 다른 세션이 s-lock을 걸고 읽는 것은 가능하지만, x-lock을 걸고 쓰는 것은 불가능 하다.

### 1-2 배타 락(Exclusive Lock, Write Lock, X-Lock)

- x-lock은 데이터를 변경하는 작업을 위해 잠그는 것을 말한다.
- 특정 데이터에 x-lock을 걸 때,
    - 하나의 세션 쓰기 작업 - 다른 세션에서 읽기 작업
      → 데이터 정합성 x, 다른 세션의 s-lock 흭득을 막음
    - 하나의 세션 쓰기 작업 - 다른 세션에서 쓰기 작업
      → 데이터 정합성X, 다른 세션의 x-lock 흭득을 막음

—> A가 x-lock을 흭득하면, 다른 어떤 세션도 해당 데이터를 읽기 위해 s-lock을 걸고 읽는 것이 불가능하고, x-lock을 걸고 쓰는 것도 불가능하다.

### 2. 블로킹

- Lock간의 경합이 발생해서 특정 트랜잭션이 작업을 진행하지 못하고 대기하는 상태

### 2-1 블로킹 상태시 해결방안

- 블로킹 상태가 길어지면 그동안 애플리케이션 서비스에서 해당 데이터를 사용하는 작업이 모두 지연된다.
- 블로킹 걸린 트랜잭션이 정해진 Lock Timeout 시간 이전에 트랜잭션이 종료되지 않으면 ERROR가 발생한다.

해결방안

1. 트랜잭션 작업 단위를 최대한 적게 구성하기
    - 트랜잭션의 작업 단위를 적게 구성하면 그만큼 빠르게 트랜잭션이 종료되기 때문에 블로킹 상태 해결이 빠르다.

1. 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계하기
    - 이런 부분은 동시성을 해결하는 비관적 락, 낙관적 락을 사용하여 해결할 수 있다.

1. 트랜잭셔인 활발한 주간에는 대용량 데이터 작업 수행 지양
    - 서비스 피크타임에 서버의 스케쥴링을 수행하면 블로킹 상태가 길어져 사용자의 불편을 초래한다.

### 3. 데드락(Dead Lock)

- 두 트랜잭션 모두가 블로킹 상태에 진입하여 서로의 블로킹을 해결할 수 없는 상태.
- 트랜잭션 A, B가 서로의 트랜잭션에 블로킹 상태로 진입하는 것을 말한다.
    - 트랜잭션 A가 B의 트랜잭션에 블로킹 상태로 진입하면 B의 트랜잭션이 정상적으로 종료되야 A의 트랜잭션이 수행된다.
    - 하지만 트랜잭션 B도 마찬가지로 A의 트랜잭션에 블로킹 상태로 진입하면 서로 블로킹 된 상태가 된다.

  → 영원히 해결할 수 없는 상태 (Dead Lock)


[Reference]

https://ksh-coding.tistory.com/121