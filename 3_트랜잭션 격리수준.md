### 트랜잭션의 격리 수준(Transaction Isolation Level)

- 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것.
- 트랜잭션의 격리 수준이 높은 순
    1. SERIALIZABLE
    2. REPEATABLE READ
    3. READ COMMITTED
    4. READ UNCOMMITED

### 1. SERIALIZABLE

- 가장 엄격한 격리 수준
- 트랜잭션을 순차적으로 처리되어, 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없다.
- 어떠한 데이터 부정합 문제도 발생하지 않지만, 동시처리 성능이 매우 떨어진다.
- 순수한 SELECT 작업에서도 대상 레코드에 넥스트 키 락을 읽기 잠금(공유락)으로 건다.
- 한 트랜잭션에서 넥스트 키 락이 걸린 레코드를 다른 트랜잭션에서는 절대 추가/수정/삭제할 수 없다.

### 2. REPEATABLE READ

- 일반적인 RDBMS는 변경 전의 레코드를 언두 공간에 백업해둔다.
- 변경 전/후 데이터가 모두 존재하므로, 동일한 레코드에 대해 여러 버전의 데이터가 존재한다.

  → 이것을 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)라고 부른다.

    - MVCC를 통해 트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수 있다.
    - 각각 트랜잭션은 순차 증가하는 고유한 트랜잭션 번호가 존재
    - 백업 레코드에는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호를 함께 저장
    - 해당 데이터가 불필요해진다고 판단하는 시점에 주기적으로 백그라운드 쓰레드를 통해 삭제

- MVCC를 이용해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우 부정합이 생길 수 있다.

- 트랜잭션 B(T-ID = 10), 트랜잭션 A(T-ID = 12)
    - T-ID : 트랜잭션 순서번호
- REPEATABLE READ는 트랜잭션 번호를 참고하여 자신보다 먼저 실행된 트랜잭션의 데이터만을 조회 한다.
    - ex) 트랜잭션 B가 끝나지 않은 상황에서 트랜잭션 A가 업데이트 쿼리로 레코드의 값을 변경하고 커밋을 한 뒤, 트랜잭션 B가 다시 SELECT를 한다면, 트랜잭션 A가 업데이트 한 값을 가져오는 것이 아닌, 언두 영역에 저장되어있는 트랜잭션 A가 업데이트 하기 전의 값을 가져오는 문제가 발생한다.

- REPEATABLE READ는 새로운 레코드의 추가까지는 막지 않는다.
    - 따라서 SELECT로 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견 될 수 있다.

      → Phantom Read(유령 읽기)

    - MVCC 덕분에 일반적인 조회에서 Phantom Read는 발생하지 않는다.
    - 그 이유는 자신보다 나중에 실행되는 트랜잭션이 추가한 레코드는 무시하기 때문이다.

- Phantom Read가 발생하는 경우
    - 잠금이 사용되는 경우
    - `SELECT WHERE id>=50 FOR UPDATE`를 사용하여 배타락을 걸면 id가 50인 것에만 락이 걸린다. (id가 50까지밖에 없다)
    - 후에 `INSERT INTO member (51,"Martin")` 를 이용하여 값을 집어넣고,
    - 다시 `SELECT WHERE id>=50 FOR UPDATE` 를 하면 결과는 2건이 나온다.

  → 그 이유는 Lock이 걸린 읽기는 데이터 조회가 언두 로그가 아닌 실제 테이블에서 수행되기 때문이다.
  → 잠금이 없는 경우처럼 언두 로그를 바라보고 언두 로그를 잠그는 것은 불가능한데, 그 이유는 언두 로그가 append only형태이므로 잠금 장치가 없기 때문이다.

  → 따라서 공유락, 배타락으로 레코드를 조회하는 경우 실제 테이블의 레코드를 가져오게 되고, 이로인해 Phantom Read가 발생한다.

- 하지만 MySQL에는 갭 락이 존재하기에 위 문제가 발생하지 않음
    - 트랜잭션 B가 `SELECT WHERE id>=50 FOR UPDATE` 를 하게되면 id가 50보다 큰 범위에는 갭 락으로 넥스트 키 락을 건다.
    - 트랜잭션 A가 id가 51인 member를 추가하고자 한다면, B의 트랜잭션이 종료될 때 까지 커밋을 대기한다.

  → 위 이유로 Phantom Read가 발생하지 않는다


- MySQL기준으로 REPEATABLE READ의 팬텀 리드 경우의 수
    - SELECT FOR UPDATE 이후 SELECT : 갭락 때문에 팬텀리드 x
    - SELECT FOR UPDATE 이후 SELECT FOR UPDATE : 갭락 때문에 팬텀리드 x
    - SELECT 이후 SELECT : MVCC때문에 팬텀리드 x
    - SELECT 이후 SELECT FOR UPDATE : 팬텀 리드 O

### 3. READ COMMITED

- 커밋된 데이터만 조회 가능
- Phantom Read에 더해 Non-Repeatable Read(반복 읽기 불가능) 문제까지 발생
1. 트랜잭션 B가 `SELECT WHERE name = “Minkyu”` 실행
   → 첫 번째 실행 결과 : 찾지 못함
   트랜잭션은 계속 진행 중
2. 중간에 트랜잭션 A가 `UPDATE SET “Minkyu” WHERE name = “Mangkyu”` 실행 후 커밋
3. 트랜잭션 B가 `SELECT WHERE name = “Minkyu”` 실행

   →두 번째 실행 결과 : 1건 찾음


—> 한 트랜잭션 내에 반복 읽기를 수행하면 조회 결과가 달라질 수 있는데, 이것을 바로 Non-Repeatable Read(반복 읽기 불가능)이라고 한다.

- Non-Repeatable Read은 일반적인 경우 문제가 되지 않지만, 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 생길 수 있다.

### 4. READ UNCOMMITED

- 커밋하지 않은 데이터 조차도 접근할 수 있는 격리 수준이다.
- 트랜잭션 A가 레코드를 추가한 뒤, 커밋하지 않아도 트랜잭션 B가 읽어올 수 있다.
  → 트랜잭션 A가 롤백된다면 다시 트랜잭션 B내에서 같은 조회를 시도하면 다른 결과를 반환하게 된다. 이것이 바로 Dirty Read(오손 읽기)

  → 조회되었다가 사라지는 현상


- READ UNCOMMITED는 RDBMS표준에서 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다. 따라서 최소한 READ COMMITED 이상의 격리 수준을 사용해야 한다.

[REFERENCE]
- https://mangkyu.tistory.com/299